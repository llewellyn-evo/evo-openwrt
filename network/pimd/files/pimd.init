#!/bin/sh /etc/rc.common
# Copyright (C) 2016 Evologics Gmbh

START=65
STOP=70

USE_PROCD=1
PROG=/usr/sbin/pimd
NAME=pimd
PIDCOUNT=0
EXTRA_COMMANDS="suspend resume"

CONFIGFILE=/var/run/$NAME.conf

LOG_ERR='logger -p daemon.err -t pimd-initscript --'
LOG_WARN='logger -p daemon.warn -t pimd-initscript --'
LOG_INFO='logger -p daemon.info -t pimd-initscript --'
LOG_DBG='logger -p daemon.debug -t pimd-initscript --'
UciState() {
	uci -P /tmp/state "$@"
}

do_validate_section()
{
	local _cr
	local _logfile=/tmp/validate_pimd.$$

	uci_validate_section "$@" >$_logfile 2>&1
	_cr=$?

	[ $_cr != 0 ] && $LOG_DBG <$_logfile
	rm -f $_logfile

	return $?
}

validate_section_pimd()
{
	# NB: 18724 = 65535 / 3.5 selon RFC4601
	# NB: default_route_* selon constantes pimd/defs.h
	do_validate_section pimd pimd "${1}" \
		'enable:bool:0' \
		'hello_interval:range(5,18724):30' \
		'default_route_metric:range(1,1024):1024' \
		'default_route_distance:range(1,255):101' \
		'igmp_query_interval:range(2,36000):125' \
		'igmp_querier_timeout:min(5):255' \
		'debug_options:string' \
		'bsr_candidate:bool:1' \
		'bsr_priority:range(0,255):5' \
		'bsr_ip:or(uci("network","@interface"),ip4addr)' \
		'bsr_interval:range(10,26214):60' \
		'rp_candidate:bool:1' \
		'rp_priority:range(0,255):20' \
		'rp_ip:or(uci("network","@interface"),ip4addr)' \
		'rp_time:range(10,16383):60' \
		'spt_mode:string:packets' \
		'spt_threshold:integer:0' \
		'spt_interval:integer:100' \
		'loglevel:range(2,8):4'
	return $?
}

validate_section_cand_group()
{
	do_validate_section pimd rp_candidate_group "${1}" \
		'grp_prefix:cidr4:224.0.0.0/4'
	return $?
}

validate_section_rp_addr()
{
	# dans pimd, le masque CIDR par défaut est /16
	do_validate_section pimd rp_static_addr "${1}" \
		'grp_prefix:cidr4' \
		'rp_addr:ip4addr'
	return $?
}

validate_section_interface()
{
	# disable par defaut pour eviter les flood involontaires
	do_validate_section pimd interface "${1}" \
		'ignore:bool:1' \
		'ttl_threshold:range(1,255):1' \
		'dr_priority:min(1):1' \
		'igmp_version:string' \
		'preference:range(1,255)' \
		'metric:range(1,1024)'
	return $?
}

add_cand_group() {
	local grp_prefix

	validate_section_cand_group "$1" || {
		$LOG_ERR local RP groups configuration is invalid
		exit 1
	}
	if [ -z "$grp_prefix" ]; then
		$LOG_WARN "Missing candidate RP group"
	else
		echo '	'group-prefix $grp_prefix >>$CONFIGFILE
	fi
}

add_rp_addr() {
	local grp_prefix rp_addr

	validate_section_rp_addr "$1" || {
		$LOG_ERR static RP address configuration is invalid
		exit 1
	}

	if [ -z "$rp_addr" ]; then
		$LOG_WARN "Group $grp_prefix associated with missing static RP address"
	else
		echo rp-address $rp_addr $grp_prefix >>$CONFIGFILE
	fi
}

start_service()
{
	local enable loglevel igmp_query_interval igmp_querier_timeout
	local bsr_candidate bsr_priority bsr_ip bsr_interval
	local rp_candidate rp_priority rp_time spt_mode spt_threshold
	local spt_interval debug_options command
	local L L2=ALERT L3=CRIT L4=ERR L5=WARNING L6=NOTICE L7=INFO L8=DEBUG

	. /lib/functions.sh
	. /lib/functions/network.sh

	config_load "${NAME}"

	validate_section_pimd pimd || {
		$LOG_ERR configuration validation failed
		return 1
	}
	debug_options="${debug_options// /,}"

	UciState set pimd.pimd.current_activation_state="$enable"
	[ 1 = "$enable" ] || return

	echo "# auto-generated from /etc/config/${NAME}" >$CONFIGFILE
	echo "disable-vifs" >>$CONFIGFILE	# default to all vifs disabled
	[ -n "$hello_interval" ] &&
		echo "hello-interval $hello_interval" >>$CONFIGFILE
	[ -n "$default_route_metric" ] &&
		echo "default-route-metric $default_route_metric" >>$CONFIGFILE
	[ -n "$default_route_distance" ] &&
		echo "default-route-distance $default_route_distance" >>$CONFIGFILE
	[ -n "$igmp_query_interval" ] &&
		echo "igmp-query-interval $igmp_query_interval" >>$CONFIGFILE
	[ -n "$igmp_querier_timeout" ] &&
		echo "igmp-querier-timeout $igmp_querier_timeout" >>$CONFIGFILE

	local ifobj interface proto l3_device device
	local ignore igmp_version dr_priority ttl_threshold preference metric
	for ifobj in `ubus list network.interface.\*`; do
		interface="${ifobj##network.interface.}"
		validate_section_interface $interface

		# Boucle necessaire pour attendre les wlan, les gre... qui passent
		# UP de facon asynchrone avec netifd. Cette boucle ne suffit pas
		# avec hostapd + DFS directement sur IP (sans bridge intermédiaire).
		local timer
		for timer in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15; do
			network_get_protocol proto $interface
			network_get_device l3_device $interface
			network_get_physdev device $interface

			[ $proto != static -a $proto != dhcp -a $proto != vrrp ] && break
			[ "$l3_device" != "" ] && break
			$LOG_DBG "waiting for $interface to come up $timer/15"
			sleep 1
			network_flush_cache
		done

		$LOG_DBG $i: $interface/$l3_device/l2=$device $proto $ignore
		l3_device=${l3_device:-$device} # si vif pas encore UP ?

		case $interface/$l3_device/$proto/$ignore in
			loopback/*/*/*)	continue;; # 127.0.0.1
			*//*/*)		continue;; # not an IP iface
			*/*/*/1)	continue;; # iface disabled
			*/*/static/*|*/*/dhcp/*|*/*/vrrp/*);; # OK !
			*)		continue;; # protocole non IP
		esac

		echo -n "phyint $l3_device enable $igmp_version" >>$CONFIGFILE
		[ -n "$dr_priority" ]	&& echo -n " dr-priority $dr_priority" >>$CONFIGFILE
		[ -n "$ttl_threshold" ]	&& echo -n " ttl-threshold $ttl_threshold" >>$CONFIGFILE
		[ -n "$preference" ]	&& echo -n " distance $preference" >>$CONFIGFILE
		[ -n "$metric" ]	&& echo -n " metric $metric" >>$CONFIGFILE
		echo >>$CONFIGFILE

		[ "$interface" = "$bsr_ip" ] && bsr_ip=$l3_device
		[ "$interface" = "$rp_ip" ] && rp_ip=$l3_device
	done

	[ "$bsr_candidate" = 1 ] &&
		echo bsr-candidate $bsr_ip interval $bsr_interval priority $bsr_priority >>$CONFIGFILE
	if [ "$rp_candidate" = 1 ]; then
		echo rp-candidate $rp_ip interval $rp_time priority $rp_priority >>$CONFIGFILE
		config_foreach add_cand_group rp_candidate_group
	fi
	[ "$spt_mode" = infinity ] && spt_threshold=
	L=$(eval echo \$L$loglevel)
	config_foreach add_rp_addr rp_static_addr
	echo spt-threshold $spt_mode $spt_threshold interval $spt_interval >>$CONFIGFILE

	command="$PROG --config=$CONFIGFILE"		# config file
	command="$command --foreground"			# foreground
	command="$command ${debug_options:+-d $debug_options}" # debug options
	command="$command -s -l $L"			# syslog level

	$LOG_INFO starting: $command
	UciState set pimd.pimd.current_command="$command"
	run_service
}

# suspend et resume peuvent être appelés depuis un autre service
# (par ex. depuis /etc/keepalived/group.pimd)
suspend()
{
	if [ "$(UciState get pimd.pimd.current_activation_state)" = 1 ]; then
		$LOG_INFO suspending
		stop
	fi
}

resume()
{
	if [ "$(UciState get pimd.pimd.current_activation_state)" = 1 ]; then
		$LOG_INFO resuming
		# exécution indirecte de run_service() par la fonction standard
		# de création de service
		rc_procd run_service "$@"
	fi
	# sinon, le dernier apply nous a mis "disable", donc ne pas redémarrer
}

run_service()
{
	local command=$(UciState get pimd.pimd.current_command)
	procd_open_instance
	procd_set_param respawn
	procd_set_param command $command
	procd_set_param file $CONFIGFILE
	procd_close_instance
}

service_triggers()
{
	procd_open_trigger
	procd_add_config_trigger "config.change" "pimd" /etc/init.d/pimd reload
	procd_add_config_trigger "config.change" "network" /etc/init.d/pimd reload
	procd_add_validation validate_section_pimd
	procd_add_validation validate_section_cand_group
	procd_add_validation validate_section_rp_addr
	procd_add_validation validate_section_interface
	procd_close_trigger
}
